/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";

import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useEffect, useMemo, useRef, useState } from "react";
import { useStore } from "../../lib/store";
export const Img = (props: { src: string; mediaType?: 'image' | 'video' }) => {
  const [map, setMap] = useState<THREE.Texture | null>(null);
  const videoRef = useRef<HTMLVideoElement | null>(null);

  const resolveUrl = (src?: string) => {
    if (!src) return "/1.jpg";
    if (src.startsWith("http") || src.startsWith("blob:") || src.startsWith("data:")) return src;
    const withRoot = src.startsWith("/") ? src : `/${src}`;
    if (withRoot.toLowerCase().includes("placeholder.jpg")) return "/1.jpg";
    return withRoot;
  };

  const isVideo = useMemo(() => {
    if (props.mediaType) return props.mediaType === 'video';
    const s = (props.src || '').toLowerCase();
    return s.startsWith('data:video') || s.endsWith('.mp4') || s.endsWith('.webm') || s.endsWith('.ogg');
  }, [props.mediaType, props.src]);

  useEffect(() => {
    let cancelled = false;
    const url = resolveUrl(props.src);
    if (isVideo) {
      const video = document.createElement('video');
      videoRef.current = video;
      video.src = url;
      video.crossOrigin = 'anonymous';
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      video.autoplay = true;
      const onCanPlay = () => {
        if (cancelled) return;
        try {
          const tex = new THREE.VideoTexture(video);
          tex.colorSpace = THREE.SRGBColorSpace as any;
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.wrapS = THREE.ClampToEdgeWrapping;
          tex.wrapT = THREE.ClampToEdgeWrapping;
          setMap(tex);
          video.play().catch(() => {});
        } catch {}
      };
      video.addEventListener('canplay', onCanPlay, { once: true });
      video.load();
      return () => {
        cancelled = true;
        try {
          video.pause();
        } catch {}
        videoRef.current = null;
      };
    } else {
      const loader = new THREE.TextureLoader();
      const proxify = (u: string) => {
        try {
          const bare = u.replace(/^https?:\/\//, '');
          return `https://images.weserv.nl/?url=${encodeURIComponent(bare)}&w=2048&h=2048&fit=inside`; // CORS-friendly proxy
        } catch { return u; }
      };
      let urlToLoad = url;
      if (urlToLoad.startsWith('http')) {
        loader.setCrossOrigin('anonymous');
        urlToLoad = proxify(urlToLoad);
      }
      let loaded = false;
      const applySafeParams = (tex: THREE.Texture) => {
        tex.colorSpace = THREE.SRGBColorSpace as any;
        // Fallback for older three versions
        // @ts-ignore
        if (tex.encoding !== undefined && (THREE as any).sRGBEncoding) tex.encoding = (THREE as any).sRGBEncoding;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        tex.anisotropy = Math.max(8, tex.anisotropy ?? 0);
        tex.needsUpdate = true;
      };
      const MAX_SIZE = 2048; // keep textures GPU-friendly
      loader.load(
        urlToLoad,
        (tex) => {
          try {
            const img: any = tex.image;
            if (img && img.width && img.height && (img.width > MAX_SIZE || img.height > MAX_SIZE)) {
              // Downscale using an offscreen canvas
              const scale = Math.min(MAX_SIZE / img.width, MAX_SIZE / img.height);
              const w = Math.max(1, Math.floor(img.width * scale));
              const h = Math.max(1, Math.floor(img.height * scale));
              const canvas = document.createElement('canvas');
              canvas.width = w; canvas.height = h;
              const ctx = canvas.getContext('2d');
              if (ctx) {
                ctx.drawImage(img, 0, 0, w, h);
                const resizedTex = new THREE.Texture(canvas);
                applySafeParams(resizedTex);
                loaded = true;
                if (!cancelled) setMap(resizedTex);
                return;
              }
            }
          } catch {}
          applySafeParams(tex);
          loaded = true;
          if (!cancelled) setMap(tex);
        },
        undefined,
        () => {
          loader.load("/1.jpg", (fallback) => {
            applySafeParams(fallback);
            loaded = true;
            if (!cancelled) setMap(fallback);
          });
        }
      );
      const t = window.setTimeout(() => {
        if (!loaded) {
          loader.load("/1.jpg", (fallback) => {
            applySafeParams(fallback);
            if (!cancelled) setMap(fallback);
          });
        }
      }, 2500);
      return () => {
        cancelled = true;
        window.clearTimeout(t);
      };
    }
  }, [isVideo, props.src]);

  const matRef = useRef<THREE.MeshBasicMaterial | null>(null);
  useEffect(() => {
    if (matRef.current) {
      matRef.current.needsUpdate = true;
    }
  }, [map]);

  return (
    <meshBasicMaterial
      ref={matRef}
      key={((map as any)?.id ?? 'no-map').toString()}
      side={THREE.DoubleSide}
      toneMapped={false}
      map={map ?? undefined}
      color={map ? undefined : "#ffffff"}
    />
  );
};
type GLTFResult = GLTF & {
  nodes: {
    Cube_1: THREE.Mesh;
    Cube_2: THREE.Mesh;
    Cube_3: THREE.Mesh;
    Cube002_1: THREE.Mesh;
    Cube002_2: THREE.Mesh;
    Cube002_3: THREE.Mesh;
    Cube003: THREE.Mesh;
    Cube003_1: THREE.Mesh;
    Cube003_2: THREE.Mesh;
  };
  materials: {
    roof: THREE.MeshStandardMaterial;
    wall: THREE.MeshStandardMaterial;
    floor: THREE.MeshStandardMaterial;
  };
};
export function Room(
  props: JSX.IntrinsicElements["group"] & { editor?: boolean },
) {
  const { nodes, materials } = useGLTF(
    "/simple_room_solidify_0.17.glb",
  ) as GLTFResult;
    const store = useStore();
  const currentRoom = store.rooms.find((room) => room.id === store.currentRoomId);
  return (
    <>
      <group
        {...props}
        castShadow
        scale={2}
        dispose={null}
        position={[2, 1.5, 2]}
      >
        <group position={[0, 1.5, 0]} scale={[1, 1, 1.2]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_1.geometry}
            material={materials.roof}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_2.geometry}
            material={materials.wall}
            material-color={currentRoom?.theme.wallColor}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_3.geometry}
            material={materials.floor}
            material-color={currentRoom?.theme.floorColor}
          />
        </group>
        <group
          position={[9, 1.5, -3]}
          rotation={[0, Math.PI / 2, 0]}
          scale={[1, 1, 1.2]}
        >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube002_1.geometry}
            material={materials.roof}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube002_2.geometry}
            material={materials.wall}
            material-color={currentRoom?.theme.wallColor}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube002_3.geometry}
            material={materials.floor}
            material-color={currentRoom?.theme.floorColor}
          />
        </group>
        <group
          position={[9, 1.5, 3]}
          rotation={[0, Math.PI / 2, 0]}
          scale={[1, 1, 1.2]}
        >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube003.geometry}
            material={materials.roof}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube003_1.geometry}
            material={materials.wall}
            material-color={currentRoom?.theme.wallColor}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube003_2.geometry}
            material={materials.floor}
            material-color={currentRoom?.theme.floorColor}
          />
        </group>{" "}
      </group>
    </>
  );
}

useGLTF.preload("/simple_room_solidify_0.17.glb");
